import chess
import networkx as nx

# Define material values for each piece type
MATERIAL_VALUES = {
    chess.PAWN: 1,
    chess.KNIGHT: 3,
    chess.BISHOP: 3,
    chess.ROOK: 5,
    chess.QUEEN: 9,
    chess.KING: 0  # King's value is not used for scaling connectivity
}

def calculate_weighted_connectivity_by_color(board):
    # Create a graph to represent the board
    G = nx.Graph()
    
    # Iterate over all squares on the board
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            # Add a node for each piece
            G.add_node(square, piece=piece.symbol())
            # Add edges for each legal move from this square
            for move in board.legal_moves:
                if move.from_square == square:
                    G.add_edge(move.from_square, move.to_square)
    
    # Calculate connectivity and scale by material value for each color
    weighted_connectivity_white = {}
    weighted_connectivity_black = {}
    
    for square in G.nodes:
        piece = board.piece_at(square)
        if piece:
            # Calculate the number of connections (degree) for this piece
            connectivity = len(list(G.neighbors(square)))
            # Scale by the material value of the piece
            weighted_value = connectivity * MATERIAL_VALUES[piece.piece_type]
            
            # Separate connectivity by color
            if piece.color == chess.WHITE:
                weighted_connectivity_white[square] = weighted_value
            else:
                weighted_connectivity_black[square] = weighted_value
    
    return weighted_connectivity_white, weighted_connectivity_black

# Example usage
board = chess.Board()  # Start from the initial position
weighted_connectivity_white, weighted_connectivity_black = calculate_weighted_connectivity_by_color(board)
print("Weighted Connectivity (White):", weighted_connectivity_white)
print("Weighted Connectivity (Black):", weighted_connectivity_black)
