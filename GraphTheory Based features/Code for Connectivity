import chess
import networkx as nx

# Define material values for each piece type
MATERIAL_VALUES = {
    chess.PAWN: 1,
    chess.KNIGHT: 3,
    chess.BISHOP: 3,
    chess.ROOK: 5,
    chess.QUEEN: 9,
    chess.KING: 0  # King's value is not used for scaling connectivity
}

def calculate_weighted_connectivity(board):
    # Create a graph to represent the board
    G = nx.Graph()
    
    # Iterate over all squares on the board
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            # Add a node for each piece
            G.add_node(square, piece=piece.symbol())
            # Add edges for each legal move from this square
            for move in board.legal_moves:
                if move.from_square == square:
                    G.add_edge(move.from_square, move.to_square)
    
    # Calculate connectivity and scale by material value
    weighted_connectivity = {}
    for square in G.nodes:
        piece = board.piece_at(square)
        if piece:
            # Calculate the number of connections (degree) for this piece
            connectivity = len(list(G.neighbors(square)))
            # Scale by the material value of the piece
            weighted_connectivity[square] = connectivity * MATERIAL_VALUES[piece.piece_type]
    
    return weighted_connectivity

# Example usage
board = chess.Board()  # Start from the initial position
weighted_connectivity = calculate_weighted_connectivity(board)
print("Weighted Connectivity:", weighted_connectivity)
